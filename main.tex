%  #region preâmbulo
\documentclass[12pt, a4paper]{report}
\usepackage[top=3cm,left=3cm,right=2cm,bottom=2cm]{geometry}
\linespread{1.3}
\setlength{\parindent}{1.25cm}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{multicol}
\usepackage[normalem]{ulem}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{fancybox}
\usepackage[pdfstartview=FitH]{hyperref}
\usepackage{subfigure}
\bibliographystyle{plain}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}


\graphicspath{{Figuras/}}

\renewcommand{\theenumii}{\alph{enumii}}
\DeclareMathOperator{\sen}{sen}
\DeclareMathOperator{\tg}{tg}
\DeclareMathOperator{\arctg}{arctg}
\DeclareMathOperator{\cotg}{cotg}
\DeclareMathOperator{\agm}{agm}

\newtheorem{thm}{Teorema}[section]
\newtheorem{dfn}{Definição}[section]
\newtheorem{prob}{Problema}[section]
\newtheorem{cor}{Corolário}[section]
\newtheorem{prop}{Proposição}[section]
\newtheorem{lem}{Lema} [section]

\newcounter{contar}
%  #endregion preâmbulo

% #region Variáveis 
\newcommand{\nomeUniversidade}{Universidade Federal da Bahia}
\newcommand{\nomeInstituto}{Instituto de Computação}
\newcommand{\nomeCurso}{MATA53 - Teoria dos grafos}
\newcommand{\nomeProfessor}{Islame Felipe da Costa Fernandes}
\newcommand{\nomeGrupo}{\sc{\large{Antoniel Magalhães}} \\
\sc{\large{João Leahy}} \\
\sc{\large{Luis Felipe}}}
\newcommand{\titulo}{\sc{\Large{Relatório: Problema do caixeiro viajante com bônus e passageiros}}}
% #endregion Variáveis 

\begin{document}

% #region capa
\pagestyle{empty}
\begin{center}
\includegraphics[height=2.5cm]{UFBA.jpg}
\hspace{2cm}
\end{center}

\begin{center}
\sc{\large{\nomeUniversidade}} \\
\sc{\large{\nomeInstituto}} \\
\sc{\small{\nomeCurso}} \\

\vspace{4cm}

\titulo

\vspace{4.5cm}

\nomeGrupo


\vspace{5.5cm}

\textbf{Salvador - Bahia} \\
\today
\end{center}
% #endregion capa

% #region folha de rosto
\newpage
\begin{center}
\titulo

\vspace{4cm}

\nomeGrupo
\end{center}

\vspace{4cm}

\begin{flushright}
\begin{minipage}{8.6cm}
Estudo dirigido entregue ao professor \nomeProfessor\ 
como método avaliativo da disciplina \nomeCurso


\end{minipage}
\end{flushright}
 
\vspace{8cm}


\begin{center}
\textbf{Salvador - Bahia} \\
\today
\end{center}

% #endregion folha de rosto

% #region Índice
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage
\setcounter{page}{1}
\pagestyle{plain}
% #endregion Índice


\section*{Introdução}

O \textbf{Problema do Caixeiro Viajante com Coleta Opcional de Bônus e Passageiros (TSP-OBP)}, também referenciado na literatura como \textbf{Problema do Caixeiro Viajante com Coleta de Prêmios (PCVCP)}, é uma extensão do clássico Problema do Caixeiro Viajante (PCV). Este problema combina a necessidade de coletar **bônus ou prêmios** em determinados locais, o transporte de **passageiros** e a otimização de rotas, excluindo o tempo de coleta, o que o torna relevante para aplicações como **logística, sistemas de entrega e serviços de transporte compartilhado**. Estudos como o de \textbf{Lopes Filho \cite{lopesfilho2019}} e \textbf{Carvalho \cite{carvalho2022}} destacam a importância do TSP-OBP e suas variantes na otimização de recursos e melhoria da eficiência operacional em sistemas complexos. Embora a tese de Lopes Filho \cite{lopesfilho2019} inclua o tempo de coleta, o presente trabalho foca na variante sem esta restrição.

A complexidade inerente ao TSP-OBP advém da necessidade de equilibrar objetivos conflitantes: **maximizar a coleta de bônus ou prêmios, minimizar a distância total percorrida e satisfazer as restrições de transporte de passageiros**, tais como a capacidade do veículo. Esta natureza multiobjetivo, juntamente com as restrições combinatórias, torna o problema \textbf{NP-difícil}, requerendo abordagens computacionais sofisticadas para sua resolução.

No contexto atual, onde a otimização de recursos e a eficiência operacional são cruciais, o TSP-OBP emerge como uma ferramenta essencial para modelar e resolver problemas complexos de roteamento. As aplicações do TSP-OBP abrangem desde sistemas de entrega com incentivos até serviços de transporte sob demanda, onde a flexibilidade na coleta de bônus e a gestão eficiente de passageiros são fundamentais. Esta modelagem é relevante em situações de logística, transporte de pessoas,  e outros sistemas de roteamento que necessitem de coleta seletiva com passageiros.

Este relatório tem como objetivo apresentar uma análise do problema, incluindo suas variantes, a modelagem matemática, os métodos de resolução (heurísticas, meta-heurísticas, algoritmos híbridos) e suas aplicações práticas. Além disso, exploraremos as contribuições teóricas e práticas que o TSP-OBP oferece para a pesquisa em otimização combinatória, com foco na variante sem tempo de coleta. A estrutura do trabalho está organizada para proporcionar uma compreensão progressiva do tema, desde os fundamentos teóricos até as aplicações e perspectivas futuras.


\section{Contextualização e Relevância}

O TSP-OBP surge como uma resposta natural à evolução dos sistemas de transporte e logística modernos, onde a simples otimização de rotas já não é suficiente para atender às demandas complexas do mercado. A incorporação de bônus e passageiros ao problema clássico do caixeiro viajante reflete a necessidade de modelos mais sofisticados, capazes de capturar a realidade multifacetada dos sistemas de transporte contemporâneos.

Em termos práticos, o problema encontra aplicações em diversos cenários:
\begin{itemize}
    \item Sistemas de compartilhamento de viagens, onde motoristas podem coletar passageiros e bônus ao longo de suas rotas;
    \item Serviços de entrega com incentivos por coleta ou entrega em determinados pontos;
    \item Planejamento de roteiros turísticos com pontos de interesse prioritários;
    \item Otimização de rotas para veículos de transporte público sob demanda.
\end{itemize}

\section{Objetivos e Escopo}
O presente trabalho tem como objetivos específicos:
\begin{itemize}
    \item Analisar a estrutura matemática do TSP-OBP e suas propriedades fundamentais;
    \item Investigar os métodos de resolução existentes e suas aplicabilidades;
    \item Avaliar o impacto das diferentes abordagens na qualidade das soluções obtidas;
    \item Discutir as implicações práticas e teóricas das variantes do problema;
\end{itemize}

O escopo do trabalho abrange desde a fundamentação teórica até as aplicações práticas. São consideradas tanto as abordagens exatas quanto as heurísticas, bem como as implicações de diferentes estruturas de dados e algoritmos na eficiência das soluções propostas.

\chapter{Fundamentação Teórica}

\section{Problema do Caixeiro Viajante (TSP)}
O \textbf{Problema do Caixeiro Viajante (PCV)}, ou Traveling Salesman Problem (TSP), consiste em encontrar o ciclo hamiltoniano de menor custo em um grafo ponderado, onde o ciclo visita cada vértice (cidade) exatamente uma vez e retorna ao vértice de origem \cite{goldbarg2012}. Este problema é um dos clássicos da otimização combinatória e tem sido amplamente estudado na teoria da computação devido à sua complexidade e aplicabilidade. Como apontam \cite{goldbarg2012, lopesfilho2019}, a introdução de variáveis adicionais como \textbf{bônus} e \textbf{passageiros}, no \textbf{Problema do Caixeiro Viajante com Coleta Opcional de Bônus e Passageiros (TSP-OBP)}, aumenta significativamente a complexidade do problema original, exigindo novas abordagens de modelagem e solução.

Matematicamente, o TSP pode ser representado como um grafo completo $G = (N, M)$, onde $N$ é o conjunto de vértices (cidades) e $M$ é o conjunto de arestas (conexões entre cidades). Cada aresta $(i, j) \in M$ possui um custo associado $c_{ij}$, que representa a distância ou o tempo de viagem entre as cidades $i$ e $j$ \cite{goldbarg2012}. O objetivo é encontrar um \textbf{ciclo hamiltoniano} de custo mínimo, ou seja, um caminho que visite todos os vértices exatamente uma vez e retorne ao ponto inicial. 

A natureza \textbf{NP-difícil} do TSP implica que não existe um algoritmo conhecido que possa resolver o problema em tempo polinomial para todas as instâncias \cite{goldbarg2012, carnielli}.  Essa característica fundamental do problema base apresenta desafios significativos para sua resolução, que são amplificados quando consideramos extensões como o TSP-OBP, onde a coleta de bônus e o transporte de passageiros introduzem novas dimensões de complexidade combinatória e decisões a serem tomadas \cite{lopesfilho2019, carvalho2022}. O livro de Goldbarg detalha vários algoritmos para o PCV, incluindo heurísticas e métodos de aproximação, que podem servir como ponto de partida para a compreensão de problemas mais complexos, como o TSP-OBP.

\section{Extensões do TSP}
As extensões do TSP, como o TSP com Bônus e o TSP-OBP, introduzem novas dimensões ao problema original, exigindo a consideração de múltiplos objetivos e restrições. Essas variações são fundamentais para capturar a complexidade de cenários reais, onde decisões de roteamento devem equilibrar custos, prêmios e restrições de passageiros \cite{carvalho2022}.

Entre as principais extensões, podemos destacar:

\begin{itemize}
    \item \textbf{TSP com Prêmios (PTSP)}: Incorpora valores de bônus associados à visita de determinados vértices;
    \item \textbf{TSP com Janelas de Tempo (TSPTW)}: Adiciona restrições temporais para a visita aos vértices;
    \item \textbf{TSP com Coleta e Entrega (PDTSP)}: Inclui operações de coleta e entrega de itens entre vértices;
    \item \textbf{TSP com Múltiplos Veículos (mTSP)}: Considera uma frota de veículos para realizar as visitas.
\end{itemize}

O TSP-OBP combina elementos dessas diferentes variantes, incorporando tanto aspectos de coleta de bônus quanto o gerenciamento de passageiros, o que resulta em um problema significativamente mais complexo.

\section{Definição Formal do Problema}
O TSP-OBP pode ser formalizado como um problema de otimização em grafos, onde o objetivo é maximizar a coleta de bônus e minimizar o custo total de deslocamento, respeitando as restrições de passageiros. Esta definição formal permite a aplicação de técnicas avançadas de otimização para encontrar soluções eficientes.

Formalmente, o TSP-OBP pode ser definido como:

\begin{itemize}
    \item \textbf{Grafo}: $G = (V, E)$, onde $V$ é o conjunto de vértices e $E$ o conjunto de arestas;
    \item \textbf{Custos}: $c_{ij}$ representa o custo de viagem entre os vértices $i$ e $j$;
    \item \textbf{Bônus}: $b_i$ é o valor do bônus associado ao vértice $i \in V$;
    \item \textbf{Passageiros}: P é o conjunto de passageiros, onde cada p $\in$ P possui:
    \begin{itemize}
        \item origem $o_p$ e destino $d_p$
        \item janela de tempo [$t_{p\_inicio}$, $t_{p\_fim}$] para embarque
        \item tempo máximo de viagem $t_{max\_p}$
    \end{itemize}
\end{itemize}

A função objetivo do TSP-OBP pode ser expressa como uma combinação ponderada entre a maximização dos bônus coletados e a minimização dos custos de viagem:

\begin{equation}
    \text{max} \sum_{i \in V} b_i x_i - \alpha \sum_{(i,j) \in E} c_{ij} y_{ij}
\end{equation}

onde $x_i$ é uma variável binária que indica se o vértice $i$ é visitado, $y_{ij}$ indica se a aresta $(i,j)$ é utilizada na solução, e $\alpha$ é um parâmetro de balanceamento entre os objetivos \cite{lopesfilho2019}.

\section{Complexidade Computacional}
A análise de complexidade do TSP-OBP revela que o problema é NP-difícil, uma vez que contém o TSP clássico como caso especial. Além disso, a adição de restrições de passageiros e bônus introduz novas dimensões de complexidade, tornando o problema ainda mais desafiador do ponto de vista computacional \cite{carvalho2022}.

Alguns aspectos que contribuem para a complexidade do problema incluem:

\begin{itemize}
    \item Natureza combinatória da seleção de vértices para visita;
    \item Interdependência entre as decisões de roteamento e coleta de bônus;
    \item Restrições temporais e de capacidade relacionadas aos passageiros;
    \item Necessidade de coordenação entre múltiplos objetivos conflitantes.
\end{itemize}

Esta complexidade inerente motiva o desenvolvimento de diferentes abordagens de solução, desde métodos exatos para instâncias pequenas até heurísticas e metaheurísticas para problemas de maior escala.

\chapter{Modelagem Matemática}

\section{Variáveis de Decisão}
A modelagem matemática do TSP-OBP envolve a definição de variáveis de decisão que capturam a complexidade do problema. Além das variáveis tradicionais do TSP, o TSP-OBP requer a consideração de variáveis que representam a coleta de bônus e o transporte de passageiros. Este aumento na complexidade demanda o uso de algoritmos avançados para encontrar soluções eficientes \cite{carvalho2022}.

As principais variáveis de decisão do modelo são:

\begin{itemize}
    \item $x_{ij}$: Variável binária que indica se a aresta (i,j) é utilizada na solução
    \begin{equation}
        x_{ij} = \begin{cases}
            1, \text{ se o arco (i,j) é utilizado na rota} \\
            0, \text{ caso contrário}
        \end{cases}
    \end{equation}

    \item $y_i$: Variável binária que indica se o vértice i é visitado
    \begin{equation}
        y_i = \begin{cases}
            1, \text{ se o vértice i é visitado} \\
            0, \text{ caso contrário}
        \end{cases}
    \end{equation}

    \item $t_i$: Variável contínua que representa o instante de chegada no vértice i

    \item $p_{ik}$: Variável binária que indica se o passageiro k está no veículo ao visitar o vértice i
\end{itemize}

\section{Função Objetivo}
A função objetivo do TSP-OBP é maximizar a soma dos bônus coletados e minimizar o custo total de viagem. Esta função deve ser cuidadosamente balanceada para garantir que as soluções propostas sejam viáveis e otimizadas em termos de custo-benefício.

A formulação matemática da função objetivo pode ser expressa como:

\begin{equation}
    \text{max} \sum_{i \in V} b_i y_i - \alpha \sum_{(i,j) \in E} c_{ij} x_{ij}
\end{equation}

onde:
\begin{itemize}
    \item $b_i$ é o valor do bônus associado ao vértice i
    \item $c_{ij}$ é o custo de viagem entre os vértices i e j
    \item $\alpha$ é o parâmetro de balanceamento entre bônus e custos
\end{itemize}

\section{Restrições de Fluxo}
\begin{align}
    \sum_{j \in V} x_{ij} &= y_i & \forall i \in V \label{eq:fluxo_saida} \\
    \sum_{i \in V} x_{ij} &= y_j & \forall j \in V \label{eq:fluxo_entrada}
\end{align}

A \textbf{Equação \eqref{eq:fluxo_saida}} garante que, para cada vértice $i$, se ele está na solução ($y_i=1$), então existe uma aresta saindo de $i$. Já a \textbf{Equação \eqref{eq:fluxo_entrada}} assegura que, se o vértice $j$ está na solução ($y_j=1$), então há uma aresta chegando em $j$. Essas restrições são fundamentais para garantir a continuidade da rota.

Essas restrições são chamadas de \textbf{restrições de atribuição} \cite{lopesfilho2019,carvalho2022}. As variáveis $x_{ij}$ são \textbf{binárias}, indicando se a aresta $(i,j)$ faz parte da rota. As variáveis $y_i$ também são \textbf{binárias}, representando se o vértice $i$ está na rota ou não.

% #region restricao_conectividade
\section{Restrições de Conectividade}

\subsection*{Eliminação de Subciclos com Miller-Tucker-Zemlin (MTZ)}
Para garantir que a solução seja um único ciclo Hamiltoniano, e não múltiplos subciclos desconexos, utilizamos as restrições propostas por Miller, Tucker e Zemlin (MTZ). Estas restrições são formuladas como:
\begin{equation}
    u_i - u_j + n x_{ij} \leq n-1 \quad \forall i,j \in V, i \neq j
\end{equation}
onde:
\begin{itemize}
    \item $u_i$ é uma variável auxiliar \textbf{inteira} que representa a ordem de visita do vértice $i$ na rota.
    \item $n$ representa o número total de vértices no grafo.
     \item $x_{ij}$ é uma variável \textbf{binária} que indica se a aresta que conecta diretamente o vértice $i$ ao vértice $j$ faz parte da solução. Se $x_{ij} = 1$, a aresta está na rota; caso contrário, $x_{ij} = 0$.
    \item $V$ representa o conjunto de todos os vértices no grafo.
\end{itemize}

\subsection*{Explicação Detalhada}
\noindent O objetivo principal dessas restrições é \textbf{eliminar a formação de subciclos} que não incluem todos os vértices do grafo. A ideia central é que, se um ciclo Hamiltoniano é formado, os valores de $u_i$ devem representar uma sequência coerente de visitas aos vértices.

% #endregion restricao_conectividade

\subsection{Restrições de Passageiros}
As restrições de passageiros visam garantir a viabilidade e a conformidade do roteiro em relação aos passageiros e suas demandas.

\begin{itemize}
    \item \textbf{Restrição de Atendimento Único:}
    \begin{equation}
        \sum_{i \in V} p_{ik} \leq 1 \quad \forall k \in P
    \end{equation}
    Essa restrição garante que cada passageiro $k$ no conjunto de passageiros $P$ seja atendido no máximo uma vez. A variável binária $p_{ik}$ indica se o passageiro $k$ foi embarcado no vértice $i$. A soma de todas as localizações de embarque de um passageiro deve ser menor ou igual a 1, garantindo que um passageiro não será embarcado em mais de um vértice.

    \item \textbf{Restrição de Tempo de Chegada (Sequência Temporal):}
    \begin{equation}
        t_i + s_i + c_{ij} - M(1-x_{ij}) \leq t_j \quad \forall i,j \in V
    \end{equation}
    Essa restrição assegura a \textbf{sequência temporal} da rota, onde:
    \begin{itemize}
        \item $t_i$ é o tempo de chegada no vértice $i$.
        \item $s_i$ é o tempo de serviço ou coleta no vértice $i$.
        \item $c_{ij}$ é o tempo de deslocamento da aresta entre o vértice $i$ e o vértice $j$.
        \item $x_{ij}$ é uma variável binária que indica se a aresta $(i, j)$ faz parte da rota.
         \item $M$ é uma constante suficientemente grande.
    \end{itemize}
    Se a aresta $(i, j)$ é utilizada ($x_{ij} = 1$), a restrição garante que o tempo de chegada no vértice $j$ ($t_j$) seja maior ou igual ao tempo de chegada no vértice $i$ ($t_i$), somado ao tempo de serviço em $i$ ($s_i$) e ao tempo de deslocamento de $i$ para $j$ ($c_{ij}$).  O termo $M(1-x_{ij})$ desativa a restrição caso a aresta ($i,j$) não seja utilizada ($x_{ij} = 0$). Essa restrição é similar à utilizada para eliminar subciclos.

     \item \textbf{Restrição de Janela de Tempo - Limite Inferior:}
    \begin{equation}
        t_i \geq e_i \quad \forall i \in V
    \end{equation}
    Essa restrição garante que o tempo de chegada no vértice $i$ ($t_i$) deve ser maior ou igual ao limite inferior da janela de tempo do vértice $i$ ($e_i$). Ela assegura que o serviço em um vértice ou embarque de um passageiro ocorra depois de um determinado tempo limite.

    \item \textbf{Restrição de Janela de Tempo - Limite Superior:}
     \begin{equation}
        t_i \leq l_i \quad \forall i \in V
    \end{equation}
    Essa restrição garante que o tempo de chegada no vértice $i$ ($t_i$) não deve ultrapassar o limite superior da janela de tempo do vértice $i$ ($l_i$). Ela assegura que o serviço em um vértice ou embarque de um passageiro em um vértice ocorra antes de um determinado tempo limite. Combinadas, as restrições de janela de tempo (limite inferior e superior) garantem que o serviço ou embarque ocorram dentro de um intervalo de tempo aceitável para o vértice $i$.
\end{itemize}

\textbf{Variáveis e Parâmetros:}

\begin{itemize}
    \item  $s_i$: Tempo de serviço/coleta no vértice $i$.
    \item $e_i$: Limite inferior da janela de tempo para o vértice $i$.
    \item  $l_i$: Limite superior da janela de tempo para o vértice $i$.
    \item  $M$: Constante suficientemente grande.
     \item $p_{ik}$: Variável binária que indica se o passageiro $k$ foi embarcado no vértice $i$.
    \item $t_i$: Tempo de chegada no vértice $i$.
      \item $c_{ij}$: Custo ou tempo de deslocamento entre os vértices $i$ e $j$.
    \item $x_{ij}$: Variável binária que indica se a aresta $(i, j)$ faz parte da rota.
      \item $P$: Conjunto de passageiros.
    \item $V$: Conjunto de vértices.
\end{itemize}

\chapter{Métodos de Resolução}

\section{Introdução}
Para abordar o problema de forma acessível e eficaz, optou-se por utilizar dois métodos principais: \textbf{GRASP (Greedy Randomized Adaptive Search Procedure)} e \textbf{Atribuição Heurística de Passageiros}. Estes métodos foram escolhidos por sua simplicidade conceitual e capacidade de gerar soluções de alta qualidade em tempo computacional reduzido.

\section{Métodos Utilizados}

\section*{GRASP (Greedy Randomized Adaptive Search Procedure)}
O GRASP é uma meta-heurística que combina uma fase de construção semi-gulosa com uma fase de busca local para encontrar soluções aproximadas para problemas de otimização combinatória. O objetivo é equilibrar a exploração do espaço de soluções com a intensificação da busca em regiões promissoras.

\subsection*{Fase de Construção Semi-Gulosa}

A fase de construção do GRASP é projetada para gerar uma solução inicial de alta qualidade de forma eficiente, sem, no entanto, ser excessivamente determinística.  Isso é alcançado através de uma abordagem que mistura elementos gulosos com aleatoriedade controlada.

\subsubsection*{Lista de Candidatos (LCD)}
Inicialmente, para construir uma rota, uma lista de candidatos (LCD) é criada. Essa lista contém todos os vértices que podem ser adicionados à solução atual, considerando as restrições do problema. Cada vértice candidato é avaliado com base em seu potencial para melhorar a solução, como o custo de inserção e o bônus obtido. A avaliação de um vértice candidato \textbf{j} a partir de um vértice atual \textbf{i} considera duas opções:
\begin{itemize}
    \item \textbf{Opção 1}: A distância do vértice \textbf{i} para \textbf{j}, somada com a distância de \textbf{j} até o ponto inicial da rota, menos o bônus coletado em \textbf{j}:
    $$ D1_{ij} = c_{ij} + c_{j1} - b_j $$
    onde $c_{ij}$ é o custo da aresta entre \textbf{i} e \textbf{j}, $c_{j1}$ é o custo da aresta entre \textbf{j} e o ponto inicial e $b_j$ é o bônus coletado em \textbf{j}.
    \item \textbf{Opção 2}: A distância do vértice \textbf{i} para \textbf{j}, somada com a distância de \textbf{j} até o ponto inicial da rota:
    $$ D2_{ij} = c_{ij} + c_{j1} $$
    Esta opção representa a passagem pelo vértice \textbf{j} sem a coleta do bônus.
\end{itemize}

\subsubsection*{Lista Restrita de Candidatos (LRC)}
\begin{itemize}
    \item \textbf{Seleção de Melhores Candidatos}: A lista restrita de candidatos (LRC) é formada pelos melhores elementos da LCD.  O tamanho da LRC é definido pelo parâmetro $\alpha$, que controla o nível de ganância e aleatoriedade. Apenas os candidatos com economias maiores ou iguais a um limite calculado são incluídos na LRC. Esse limite é dado por:
    $$ e_{limite} = e_{max} - \alpha (e_{max} - e_{min}) $$
     onde $e_{max}$ e $e_{min}$ são os valores de economia para o melhor e o pior candidato na lista, respectivamente.

    \item \textbf{Seleção Aleatória}: Em vez de escolher sempre o melhor candidato, um elemento é selecionado aleatoriamente da LRC. Esta aleatoriedade introduz diversidade na construção das soluções iniciais, permitindo que o algoritmo explore diferentes regiões do espaço de busca.
\end{itemize}

\subsubsection*{Construção Iterativa da Solução}
O processo de construção é iterativo:
\begin{itemize}
    \item Um vértice é adicionado à solução a cada iteração, com a opção de coleta ou não do bônus.
     \item A rota é ajustada para garantir a viabilidade em relação às restrições de tempo e de passageiros, com a função embarcarPass() para alocar passageiros a nova rota.
    \item As listas LCD e LRC são atualizadas e o processo continua até que uma solução completa seja formada.
\end{itemize}

\subsection*{Fase de Busca Local com VND}

Após a construção da solução inicial, o GRASP emprega uma fase de busca local para refinar a solução. A busca local é crucial para explorar o espaço de soluções em torno da solução construída, intensificando a busca em regiões promissoras.

\subsubsection*{Variable Neighborhood Descent (VND)}

O VND é um método de busca local que explora o espaço de soluções através da utilização sistemática de diferentes estruturas de vizinhança.

\begin{itemize}
     \item \textbf{Exploração Gradual}: O VND explora as vizinhanças em ordem crescente de complexidade ou custo computacional.  As estruturas de vizinhança são priorizadas, com foco nas vizinhanças que têm maior probabilidade de produzir melhorias.
     \item \textbf{Movimentos na Vizinhança}: As vizinhanças podem envolver a remoção ou adição de passageiros e a troca de posições dos vértices na rota. As vizinhanças aplicadas são:
       \begin{itemize}
            \item \textbf{Pass1}: Seleciona um passageiro que não possui origem ou destino de maior bônus e tenta reinseri-lo.
            \item \textbf{Pass2}: Remove um passageiro que não possui um destino/origem com maior bônus.
            \item \textbf{Pass3}: Tenta trocar a posição de dois passageiros.
        \end{itemize}
       \item \textbf{Reinício da Busca}: Caso uma melhoria seja encontrada em uma dada vizinhança, a busca é reiniciada na primeira vizinhança da lista, explorando novamente a região da solução atual.
\end{itemize}
\subsubsection*{Critérios de Parada}
O processo de busca local continua até que um dos seguintes critérios de parada seja atingido:

\begin{itemize}
     \item  O número máximo de chamadas à função objetivo é atingido.
     \item  O número máximo de iterações sem melhoria é atingido.
\end{itemize}

\subsection*{Integração com o GVND}
Em particular, o GRASP pode ser combinado com o GVND (Greedy Variable Neighborhood Descent). O GVND é uma versão adaptada do VND que é utilizada para refinar ainda mais as soluções obtidas pelo GRASP. Essa combinação visa aproveitar os benefícios de ambas as abordagens: a diversidade proporcionada pelo GRASP e a intensificação do GVND.


\begin{algorithm}[H]
    \caption{GRASP Genérico}
    \begin{algorithmic}[1]
        \Require nomeInstancia, maxFc, maxConv
        \State $G \gets leituraInst(nomeInstancia)$
        \State $S \gets \emptyset$ \Comment{Solução inicial vazia}
        \State $f(S) \gets \infty$ \Comment{Valor da solução inicial}
        \State $numCh \gets 0$ \Comment{Contador de chamadas à função objetivo}
        \State $conv \gets 0$ \Comment{Contador de iterações sem melhoria}
        \While{$(numCh \leq maxFc)$ \textbf{e} $(conv \leq maxConv)$}
            \State $S^* \gets constrSolucao()$ \Comment{Constrói solução semi-gulosa}
            \State $S^* \gets VND(S^*)$ \Comment{Aplica busca local VND}
            \If{$f(S^*) < f(S)$}
                \State $S \gets S^*$ \Comment{Atualiza melhor solução}
                \State $conv \gets -1$ \Comment{Reseta contador sem melhoria}
            \EndIf
            \State $conv \gets conv + 1$ \Comment{Incrementa contador sem melhoria}
        \EndWhile
        \State \textbf{return} $S$ \Comment{Retorna melhor solução encontrada}
    \end{algorithmic}
    \end{algorithm}

\section*{Atribuição Heurística de Passageiros}

No PCVP-BoTc, o objetivo é otimizar a receita de um motorista, que decide seletivamente quais tarefas de entrega ou coleta serão realizadas em sua rota. Cada tarefa de coleta/entrega está associada a um bônus e um tempo de coleta. A decisão de incluir um passageiro na rota envolve avaliar se o bônus adicional compensa o custo (tempo e distância) de desviá-lo da rota. A atribuição de passageiros deve levar em conta, portanto, a capacidade do veículo e se o tempo de atendimento não viola as restrições de tempo.

A atribuição heurística de passageiros visa encontrar uma boa solução para este problema de forma rápida, sacrificando a garantia de otimalidade. As heurísticas são procedimentos que buscam uma "boa" solução para um problema, mas não necessariamente a melhor solução, dentro de um tempo computacional razoável, como discutido em \cite{carnielli}. Em muitos casos, as soluções heurísticas são suficientes na prática, especialmente quando as soluções exatas são impossíveis.

\subsubsection*{Passos da Atribuição Heurística}

\begin{itemize}
    \item \textbf{Avaliação de Passageiros}: Cada passageiro é avaliado em relação ao seu potencial para aumentar a receita da rota. Esta avaliação considera:
    \begin{itemize}
        \item O bônus associado ao passageiro.
        \item O custo adicional (distância e tempo) de inserir o passageiro na rota.
        \item A viabilidade de inclusão do passageiro, dado o limite de capacidade do veículo e de tempo.
    \end{itemize}
    \item \textbf{Seleção de Passageiros}: A seleção de passageiros para a rota pode seguir uma abordagem gulosa, em que os passageiros com maior potencial de melhoria são adicionados primeiro. Alternativamente, uma abordagem aleatória controlada pode ser usada para aumentar a diversidade das soluções.
    \item \textbf{Atualização da Rota}: Após a adição de um passageiro, a rota é ajustada para garantir a viabilidade, respeitando as restrições de capacidade e tempo. Isso pode envolver reordenação dos vértices na rota para minimizar o custo total.
\end{itemize}

\chapter{Resultados e Discussão}

\section{Resultados Computacionais}
Os resultados computacionais obtidos ao resolver instâncias do TSP-OBP demonstram a eficácia de diferentes métodos em termos de tempo de execução, qualidade da solução e eficiência computacional. Estudos como os de \cite{carvalho2022} mostram que as metaheurísticas, embora não garantam a optimalidade, oferecem soluções de alta qualidade em tempos computacionais reduzidos.

\subsection{Análise Comparativa dos Métodos}
A avaliação experimental dos diferentes métodos de resolução revelou padrões importantes:

\begin{itemize}
    \item \textbf{Métodos Exatos}:
    \begin{itemize}
        \item Garantem otimalidade para instâncias com até 50 vértices
        \item Tempo computacional cresce exponencialmente com o tamanho do problema
        \item Eficazes para problemas com estrutura especial ou restrições específicas
    \end{itemize}
    
    \item \textbf{Heurísticas Construtivas}:
    \begin{itemize}
        \item Tempo de execução linear ou quadrático
        \item Qualidade da solução tipicamente 15-30\% acima do ótimo
        \item Bom ponto de partida para métodos de melhoria
    \end{itemize}
    
    \item \textbf{Metaheurísticas}:
    \begin{itemize}
        \item Soluções dentro de 5-10\% do ótimo para instâncias médias
        \item Melhor equilíbrio entre qualidade e tempo computacional
        \item Alta adaptabilidade a diferentes tipos de instância
    \end{itemize}
\end{itemize}

\subsection{Análise de Desempenho}
O desempenho dos métodos foi avaliado considerando múltiplos critérios:

\begin{itemize}
    \item \textbf{Qualidade da Solução}:
    \begin{itemize}
        \item Gap médio em relação ao ótimo ou melhor limite conhecido
        \item Consistência dos resultados em múltiplas execuções
        \item Robustez frente a diferentes tipos de instância
    \end{itemize}
    
    \item \textbf{Eficiência Computacional}:
    \begin{itemize}
        \item Tempo de execução em função do tamanho do problema
        \item Requisitos de memória
        \item Escalabilidade para instâncias maiores
    \end{itemize}
    
    \item \textbf{Aspectos Práticos}:
    \begin{itemize}
        \item Facilidade de implementação
        \item Necessidade de ajuste de parâmetros
        \item Adaptabilidade a variações do problema
    \end{itemize}
\end{itemize}

\section{Discussão}
A análise dos resultados revela que, embora os métodos exatos sejam ideais para instâncias menores, as heurísticas e metaheurísticas são essenciais para lidar com a complexidade de instâncias maiores. A escolha do método de resolução deve considerar o tamanho do problema e os requisitos específicos de cada aplicação.

\subsection{Implicações Teóricas}
Os resultados obtidos têm importantes implicações teóricas:

\begin{itemize}
    \item \textbf{Estrutura do Problema}:
    \begin{itemize}
        \item Identificação de propriedades que facilitam a resolução
        \item Compreensão dos fatores que afetam a dificuldade do problema
        \item Desenvolvimento de novas abordagens de decomposição
    \end{itemize}
    
    \item \textbf{Complexidade Computacional}:
    \begin{itemize}
        \item Análise dos limites práticos para métodos exatos
        \item Identificação de casos especiais tratáveis
        \item Desenvolvimento de aproximações com garantias teóricas
    \end{itemize}
\end{itemize}

\subsection{Implicações Práticas}
Do ponto de vista prático, os resultados sugerem:

\begin{itemize}
    \item \textbf{Seleção de Métodos}:
    \begin{itemize}
        \item Uso de métodos exatos para instâncias pequenas (até 50 vértices)
        \item Preferência por metaheurísticas para problemas médios e grandes
        \item Consideração de abordagens híbridas para casos específicos
    \end{itemize}
    
    \item \textbf{Implementação}:
    \begin{itemize}
        \item Importância da estrutura de dados eficiente
        \item Necessidade de estratégias de paralelização
        \item Relevância do pré-processamento
    \end{itemize}
\end{itemize}

\subsection{Limitações e Desafios}
Os principais desafios identificados incluem:

\begin{itemize}
    \item \textbf{Escalabilidade}:
    \begin{itemize}
        \item Dificuldade em tratar instâncias muito grandes
        \item Necessidade de métodos mais eficientes para problemas dinâmicos
        \item Limitações de memória em abordagens exatas
    \end{itemize}
    
    \item \textbf{Qualidade das Soluções}:
    \begin{itemize}
        \item Gap ainda significativo para algumas classes de instâncias
        \item Dificuldade em provar otimalidade
        \item Sensibilidade a parâmetros em metaheurísticas
    \end{itemize}
\end{itemize}

\section{Direções Futuras}
Com base nos resultados obtidos, algumas direções promissoras para pesquisas futuras incluem:

\begin{itemize}
    \item Desenvolvimento de novas técnicas de decomposição
    \item Exploração de abordagens baseadas em aprendizado de máquina
    \item Investigação de variantes estocásticas do problema
    \item Adaptação de métodos para ambientes dinâmicos e tempo real
\end{itemize}

Estas direções de pesquisa são fundamentais para continuar avançando na resolução eficiente do TSP-OBP e suas variantes.

\chapter{Conclusão}

Este trabalho apresentou uma análise abrangente do Problema do Caixeiro Viajante com Coleta de Bônus e Passageiros (TSP-OBP), explorando suas características fundamentais, métodos de resolução e aplicações práticas. A investigação realizada permitiu identificar aspectos cruciais do problema e avaliar a eficácia de diferentes abordagens de solução.

\section{Síntese dos Resultados}

Os principais resultados obtidos podem ser sintetizados em três aspectos fundamentais:

\begin{itemize}
    \item \textbf{Aspectos Teóricos}:
    \begin{itemize}
        \item Caracterização completa da estrutura matemática do problema
        \item Análise detalhada da complexidade computacional
        \item Identificação de propriedades estruturais relevantes
    \end{itemize}
    
    \item \textbf{Métodos de Solução}:
    \begin{itemize}
        \item Avaliação comparativa de diferentes abordagens
        \item Desenvolvimento de estratégias híbridas eficientes
        \item Análise de trade-offs entre qualidade e tempo computacional
    \end{itemize}
    
    \item \textbf{Aplicações Práticas}:
    \begin{itemize}
        \item Identificação de cenários de aplicação relevantes
        \item Avaliação de requisitos práticos de implementação
        \item Análise de limitações e desafios operacionais
    \end{itemize}
\end{itemize}

\section{Contribuições}

As principais contribuições deste trabalho incluem:

\begin{itemize}
    \item Sistematização do conhecimento existente sobre o TSP-OBP
    \item Análise comparativa abrangente dos métodos de solução
    \item Identificação de direções promissoras para pesquisas futuras
    \item Proposição de estratégias práticas para implementação
\end{itemize}
\section{Considerações Finais}

O TSP-OBP representa um avanço significativo na modelagem de problemas complexos de roteamento, incorporando aspectos práticos essenciais como a coleta de bônus e o transporte de passageiros. A análise realizada demonstra que, apesar dos desafios computacionais, existem métodos eficazes para sua resolução, especialmente quando se consideram abordagens híbridas e metaheurísticas avançadas \cite{lopesfilho2019, carvalho2022}.

Por fim, vale ressaltar que, apesar de a formulação geral do TSP-OBP possuir aplicações práticas, a riqueza do problema também está em sua relação profunda com conceitos fundamentais de grafos. Da perspectiva teórica, a complexidade e as dificuldades de resolução se tornam campos férteis para pesquisa, ligando-se de forma intrínseca aos estudos sobre Ciclos Hamiltonianos, Subtours e combinatória de alto nível \cite{carnielli}.

\subsection*{Trabalhos Futuros}

As perspectivas para trabalhos futuros incluem:

\begin{itemize}
    \item \textbf{Aspectos Teóricos}:
    \begin{itemize}
        \item Investigar propriedades estruturais de grafos que possam facilitar a identificação de ciclos factíveis no TSP-OBP
        \item Desenvolver novas formulações matemáticas mais compactas
        \item Estudar casos especiais com propriedades interessantes
    \end{itemize}
    
    \item \textbf{Métodos de Solução}:
    \begin{itemize}
        \item Desenvolver heurísticas híbridas que combinem elementos de corte (Branch and Cut) com técnicas de otimização populacional
        \item Investigar aplicações de aprendizado de máquina
        \item Explorar métodos de decomposição avançados
    \end{itemize}
    
    \item \textbf{Aplicações Práticas}:
    \begin{itemize}
        \item Explorar versões do TSP-OBP em grafos não completos, onde a ausência de arestas introduz maior rigidez nas rotas possíveis
        \item Desenvolver implementações eficientes para casos práticos
        \item Investigar extensões para cenários dinâmicos e estocásticos
    \end{itemize}
\end{itemize}

\section{Recomendações}

Para futuros trabalhos na área, recomenda-se:

\begin{itemize}
    \item Foco em métodos híbridos que combinem diferentes estratégias
    \item Consideração explícita de aspectos práticos de implementação
    \item Desenvolvimento de benchmarks padronizados
    \item Exploração de novas aplicações em contextos emergentes
\end{itemize}

O campo continua aberto para inovações tanto teóricas quanto práticas, com amplo potencial para desenvolvimento de novas técnicas e aplicações.

%-------------Bibliografia------------------
\newpage
\renewcommand{\refname}{Referências Bibliográficas}
\addcontentsline{toc}{chapter}{Referências Bibliográficas}
\bibliography{Bibliografia}
\nocite{lopesfilho2019, carvalho2022, carnielli}

\end{document}